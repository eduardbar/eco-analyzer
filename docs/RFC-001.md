# RFC-001: Estructura de Componentes y UI/UX del Frontend

**Fecha:** 2025-08-06 **Autor:** Equipo de Frontend **Estado:** Propuesto

## 1. Resumen

Este RFC define la arquitectura de la interfaz de usuario (UI), la experiencia de usuario (UX) y la estructura de componentes para el frontend de la aplicación, que se construirá con **Next.js**, **TypeScript** y **Tailwind CSS**. El objetivo es crear una interfaz limpia, intuitiva y visualmente atractiva utilizando un diseño de **glassmorphism**.

## 2. Filosofía de Diseño (UX)

La experiencia del usuario debe ser directa y sin fricciones. El flujo principal se centra en una única acción: analizar un producto.

- **Flujo Principal:**
  1. **Entrada:** El usuario llega a la página principal y ve inmediatamente un área de entrada de texto.
  2. **Acción:** El usuario pega una descripción y hace clic en "Analizar".
  3. **Feedback:** El sistema muestra un estado de carga claro e inmediato.
  4. **Resultado:** Los resultados se muestran en la misma vista, reemplazando el formulario de entrada, con una animación suave. La información más importante (Eco-Score) es la más prominente.
  5. **Reinicio:** Un botón claro permite al usuario realizar un nuevo análisis.
- **Diseño Visual (UI):**
  - **Glassmorphism:** Los elementos interactivos (tarjetas, inputs) tendrán un fondo semitransparente con un desenfoque (backdrop-filter), bordes sutiles y un ligero brillo para simular el efecto de vidrio esmerilado.
  - **Paleta de Colores:** Un fondo degradado oscuro (de morado a azul) para crear contraste y hacer que los elementos de "vidrio" resalten. Los colores de acento (verde, amarillo, rojo) se usarán para indicar la calidad del Eco-Score.
  - **Tipografía:** Se utilizará una fuente sans-serif moderna y legible (como Inter o similar) para garantizar la claridad.

## 3. Arquitectura de Componentes

Proponemos una estructura de componentes atómica y reutilizable dentro de la carpeta `/app/components`.

- **Componentes Contenedores (Páginas):**
  - `app/page.tsx`: La página principal que orquesta la lógica de estado y renderiza condicionalmente el formulario de entrada o la vista de resultados.
- **Componentes de UI Reutilizables (`/app/components/ui`):**
  - `GlassCard.tsx`: Un componente base que aplica los estilos de glassmorphism. Aceptará `children` para renderizar cualquier contenido en su interior.
  - `AnalysisForm.tsx`: Un componente que encapsula el `<form>`, el `<textarea>` y el botón de envío. Gestiona el estado local del input y emite el evento `onSubmit` al componente padre.
  - `LoadingSpinner.tsx`: Un indicador de carga visual (por ejemplo, un spinner animado con el ícono `<Hourglass>`).
  - `CustomButton.tsx`: Un botón estilizado que puede mostrar un estado de carga.
- **Componentes de Dominio (`/app/components/analysis`):**
  - `ResultDisplay.tsx`: El componente principal para mostrar los resultados. Recibirá el objeto `analysisResult` como prop.
  - `EcoScoreGauge.tsx`: Un componente visualmente impactante para mostrar la puntuación principal. Usará colores dinámicos según el valor.
  - `MetricCard.tsx`: Un componente para mostrar métricas individuales como "Huella de Carbono" o "Uso de Agua". Recibirá un ícono, un título, un valor y una descripción.
  - `MaterialsList.tsx`: Un componente para iterar y mostrar la lista de análisis de materiales.
  - `ErrorDisplay.tsx`: Un componente para mostrar un mensaje de error de manera consistente si la llamada a la API falla.

## 4. Gestión del Estado

Para la fase inicial, el estado se gestionará localmente en el componente `app/page.tsx` utilizando hooks de React:

- `useState<string>(''):` para el valor del `textarea`.
- `useState<boolean>(false):` para el estado `isLoading`.
- `useState<AnalysisResult | null>(null):` para almacenar el resultado del análisis.
- `useState<string | null>(null):` para los mensajes de error.

Este enfoque evita la complejidad de una librería de gestión de estado global (como Redux o Zustand) que no es necesaria en esta etapa.

## 5. Próximos Pasos

1. Implementar los componentes de UI base en la carpeta `/app/components/ui`.
2. Construir el componente `AnalysisForm`.
3. Desarrollar los componentes de visualización de resultados en `/app/components/analysis`.
4. Ensamblar todo en `app/page.tsx` y conectar la lógica de estado para simular el flujo completo con datos mock.