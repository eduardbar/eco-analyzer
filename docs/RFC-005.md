# RFC-005: Lógica del Motor de Análisis Principal

**Fecha:** 2025-08-06 **Autor:** Equipo de Backend **Estado:** Aprobado

## 1. Resumen

Este RFC detalla la lógica interna del servicio de análisis, que es el corazón de la aplicación. Describe cómo se interactuará con la IA externa, cómo se calculará el **Eco-Score** y cómo se estructurará el código para mantener la claridad y la mantenibilidad.

## 2. Interacción con la API de IA (OpenAI)

Se creará una clase o un objeto de servicio llamado `AIClient` para encapsular toda la lógica de comunicación con la API de OpenAI.

- **Método Principal:** `async getAnalysis(description: string): Promise<AIResponse>`

- **Construcción del Prompt:** Este es el paso más crucial. El método construirá un prompt dinámico y muy específico.

  **Ejemplo de Prompt:**

  ```
  Eres un experto en análisis del ciclo de vida de productos de consumo. Analiza la siguiente descripción y responde ÚNICAMENTE con un objeto JSON válido. No incluyas texto antes o después del JSON.
  
  Descripción del producto: "${description}"
  
  Basado en la descripción, proporciona estimaciones razonables para un producto de esa categoría.
  
  La estructura del JSON debe ser la siguiente:
  {
    "productTitle": "Un nombre corto y descriptivo para el producto",
    "estimatedCarbonFootprintKg": <número>,
    "estimatedWaterUsageLiters": <número>,
    "materialsAnalysis": [
      { "materialName": "string", "sustainabilityScore": <número del 1 al 10>, "notes": "Breve justificación de la puntuación." }
    ],
    "endOfLife": { "recyclable": <boolean>, "notes": "Notas sobre la reciclabilidad." },
    "overallSummary": "Un resumen de 2-3 frases sobre el impacto general del producto."
  }
  ```

- **Manejo de la Respuesta:**

  1. Se utilizará el modo de respuesta JSON de la API de OpenAI para garantizar que la salida sea un JSON válido.
  2. La respuesta JSON se validará usando una librería como **Zod** para asegurar que la estructura y los tipos de datos coinciden con lo esperado antes de procesarla. Esto previene errores si la IA devuelve un formato inesperado.

## 3. Cálculo del Eco-Score

Una vez que se recibe y valida la respuesta de la IA, el `AnalysisService` calculará el Eco-Score.

- **Fórmula Propuesta:** El Eco-Score será una puntuación de 0 a 100, donde 100 es el mejor resultado (menor impacto). La fórmula se basará en la normalización y ponderación de los valores clave.

  1. **Normalización:** Cada métrica (carbono, agua, materiales) se convertirá a una escala de 0 a 100.
     - `carbonScore = 100 - (min(carbonFootprint, MAX_CARBON) / MAX_CARBON) * 100`
     - `waterScore = 100 - (min(waterUsage, MAX_WATER) / MAX_WATER) * 100`
     - `materialsScore = (promedio de sustainabilityScore de todos los materiales) * 10`
  2. **Ponderación:** Se aplicarán pesos a cada puntuación normalizada.
     - **Pesos Iniciales:** Carbono: 40%, Agua: 30%, Materiales: 30%.
     - `EcoScore = (carbonScore * 0.4) + (waterScore * 0.3) + (materialsScore * 0.3)`

  *Estos valores (`MAX_CARBON`, `MAX_WATER`, y los pesos) serán configurables a través de variables de entorno para poder ajustarlos fácilmente.*

## 4. Estructura del Servicio

El código se organizará en `src/services/analysis.service.ts`.

```
// src/services/analysis.service.ts
import { AIClient } from './ai.client';
import { prisma } from '../lib/prisma';
import { calculateEcoScore } from '../utils/eco-score.calculator';

class AnalysisService {
  public async analyzeProduct(description: string, userId: number) {
    // 1. Obtener análisis de la IA
    const aiResponse = await AIClient.getAnalysis(description);

    // 2. Validar respuesta con Zod (no mostrado)

    // 3. Calcular el Eco-Score
    const ecoScore = calculateEcoScore(aiResponse);

    // 4. Guardar en la base de datos usando Prisma
    const savedAnalysis = await prisma.analysis.create({
      data: {
        productTitle: aiResponse.productTitle,
        ecoScore: ecoScore,
        summary: aiResponse.overallSummary,
        carbonFootprint: aiResponse.estimatedCarbonFootprintKg,
        waterUsage: aiResponse.estimatedWaterUsageLiters,
        userId: userId,
        materials: {
          create: aiResponse.materialsAnalysis.map(mat => ({
            materialName: mat.materialName,
            sustainabilityScore: mat.sustainabilityScore,
            notes: mat.notes,
          })),
        },
      },
      include: {
        materials: true, // Devolver los materiales creados en la respuesta
      },
    });

    return savedAnalysis;
  }
}

export const analysisService = new AnalysisService();
```